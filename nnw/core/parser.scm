(define-module (nnw core parser)
  #:use-module (nnw core generic)
  #:use-module (nnw core utils)
  #:use-module (nnw core view)
  #:use-module (nnw core type)
  #:use-module (oop goops)
  #:use-module (sxml match)
  #:use-module (srfi srfi-1)
  #:export (parse-text))

(define (fold-view-blocks . view-blocks)
  (fold (lambda (pair acc)
	  (cons (append (car pair) (car acc))
		(append (cdr pair) (cdr acc)))) '(() . ()) view-blocks))

(define (replace-child child)
  (if (equal? (car child) 'view)
      (sxml-match child
	((view (@ (id ,id) . ,otr) . ,chd)
	 `(view (@ (id ,id))))
	(,otherwise
	 `(id ,(input->views+blocks child))))
      child))

(define (replaced-id-filter child)
  (if (equal? (car child) 'id)
      #t
      #f))

(define (parse-modified-child child)
  (if (equal? (car child) 'id)
      (let* ((views-blocks (cadr child))
	     (view (caar child)))
	`(view (@ (id ,(get-id view)))))
      child))

(define (replace-input-views input)
  (sxml-match-let (((view (@ . ,meta) . ,children)
		    input))
    (let* ((replaced-children (map replace-child children))
	   (modified-children (map parse-modified-child children))
	   (views-blocks (map (lambda (child)
				(cadr child))
			      (filter replaced-id-filter children))))
      (cons `(view (@ ,@meta) ,@modified-children)
	    views-blocks))))

(define-method (input->views+blocks (input <list>))
  ;; (display "input=")
  ;; (write input)
  ;; (newline)
  (sxml-match-let (((view (@ (type ,type) . ,otr) . ,children) input))
    (let* ((replaced-input+views-blocks (replace-input-views input))
	   (replaced-input (car replaced-input+views-blocks))
	   (views-blocks (cdr replaced-input+views-blocks)))
      (apply fold-view-blocks
	     (cons (input->views+blocks replaced-input
					(string->view-type type))
		   views-blocks)))))

(define (parse-text-block tags lines)
  (map (lambda (line)
    `(block (@ (type "text")
	       ,@(if (not (null? tags))
		     `((tags ,(string-join tags " ")))
		     '()))
	    (p ,line))) lines))

(define* (parse-text source #:key (tags '())
                                  (view-id #f)
				  (view-type "document")
				  (view-name "Untitled Document")
				  (view-metadata '()))
  (let* ((lines (filter (lambda (line) (not (string=? line "")))
			(string-split source #\newline)))
	 (blocks (parse-text-block tags lines)))
    `(view (@ (type ,view-type)
              (name ,view-name)
	      ,@view-metadata
	      ,@(if view-id `((id ,view-id)) '()))
           ,@blocks)))
